git：是一个免费并且开源的分布式版本控制系统

版本控制系统：保留文件的所有的修改历史记录，可以方便地撤销之前对文件的修改操作。

git add做了什么？
1>git add 添加一个文件，让git对它进行追踪，那么为什么最总之后，我们再次提交的时候，还需要commit呢？这就涉及到add做了什么。
2>文件的三种状态：已修改（被修改的文件）
 已暂存（等待被提交的文件）
 已提交（提交到本地仓库的文件）
3>三个工作区域：工作目录（已修改）
    暂存区域（已暂存）
    Git仓库（已提交)
4>Git工作流程：a.在工作目录中修改文件
                           b.暂存文件
                           c.提交更新，找到暂存区文件
注：未被git追踪的文件不参与一下三种状态，我们称之为未追踪状态（Untracked）

Stage阶段：筹划、组织和准备某个事物
“staging area”集合待命地区
所以我们可以理解为我们通过add添加的文件进入了准备区域等待被提交这样的区域我们成为“暂存区”

提交对象：
Git保存的并不是文件的变化或者差异，而是一系列的不同时刻的文件快照，提交操作时，Git会保存一个提交对象，该对象中包含一个指向暂存内容快照的指针、作者姓名、邮箱、父对象指针以及提交输入信息。
注：1>首次提交的对象没有父对象
 2>普通的提交有一个父对象
 3>多个分支合并的有多个父对象

master分支：
1>Git的分支本质上仅仅是指向提交对象的可变指针。
2>Git默认分支名：master它会在每一次的提交中自动前移。
注：Git的分支master并不是一个特殊的分支，它和其他的分支完全没有区别，之所以每个分支都是有master是git init命令默认创建，而大部分人懒得修改而已。
如：某天完成了项目的一次开发后，准备开始二次方，但是如果直接在一次开发的基础上更改我们的文件就是第一次+第二次，管理起来相当不方便，这时便需要分支。

快速前移（Fast-forward）:不是很友好
当master和branch没有形成分叉，依旧是处于一条路径线，当HEAD落后于所要合并的分支，将会形成快速前移。

Reset的本质：
可以用来撤销commit，但实质行为上并不是撤销操作，而是移动HEAD并且带上所指向的分支，重置HEAD及分支，重置HEAD及分支，即在HEAD之后的提交，因为当前不在任何分支上，就不会出现在工作目录中，起到撤销效果。
注：该提交并未丢失，可以通过哈希找回

多人合作模式：
中央仓库：
存储每个成员的提交对象，共享提交对象给每个成员
分布式版本控制系统：
分布在每个成员的电脑上，都有一个本地仓库，任何一个电脑的本地仓库不小心丢失，都可以从成员处找回，或者可以从中央仓库进行下载共享，保存历史记录的任务分配到每个开发成员的身上，中央仓库只需要整合共享。

